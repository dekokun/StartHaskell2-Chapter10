<!doctype html>  
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    
    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    
    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  
  <body>
    
    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1>スタートHaskell 2</h1>
          <h3>関数型問題解決法</h3>
          <h5>@dekokun</h5>
        </section>
        
        <section data-markdown>
          ## 自己紹介
          * @dekokun
          * Web企業でPHPとかPerlとかNodeとか
          * 最近Jenkinsが好き
          * 静的な型付け言語は手慰みにCやJavaをやったこともあるがHaskellがほぼ初めて！
          * 静的型付け言語、楽しいですね！！！
          * Haskell製のブログエンジン、Hakyleを使って作ったブログとかあるし見てね！
        </section>

        <section data-markdown>
          ## 逆ポーランド記法電卓
        </section>

        <section data-markdown>
          ### 逆ポーランド記法(RPN)とは
          * こんな感じ
            * "1  2 +" -> 1 + 2
            * "1  2 + 10 *" -> (1 + 2) * 10
          * ()が不要ですね。素敵ですね。

        </section>

        <section data-markdown>
          ### 計算方法

          * 左から右に読む
          * 数だったらスタックに積む
          * 演算子だったらスタックから数を取り出し演算し、結果をスタックに積む
          * 最後にスタックに残った数が答え
        </section>

        <section data-markdown>
          ## 実際に自分の頭で計算してみる
          * "10 4 3 + 2 * -"
        </section>

        <section data-markdown>
          ### まずはスタックに10を積む
          * "10 4 3 + 2 * -"
          * スタック:10
        </section>

        <section data-markdown>
          ### 次のアイテムは4なのでこれも<br>スタックに積む
          * "4 3 + 2 * -"
          * スタック:4 10
        </section>
        <section data-markdown>
          ### 次も3なのでスタックに
          * "3 + 2 * -"
          * スタック:3 4 10
        </section>

        <section data-markdown>
          ### 次は2項演算子なのでスタックから2個取り出して計算し結果をスタックに積む
          * "+ 2 * -"
          * 4 + 3 = 7
          * スタック:7 10
        </section>

        <section data-markdown>
          ### 2をスタックに
          * "2 * -"
          * スタック:2 7 10
        </section>

        <section data-markdown>
          ### 掛け算
          * "* -"
          * 7 * 2 = 14
          * スタック:14 10
        </section>
        <section data-markdown>
          ### 引きましょう
          * "-"
          * 10 - 14 = -4
          * スタック:4
        </section>
        <section data-markdown>
          ### なくなった
          * ""
          * スタック:4

          お疲れ様です。答えは4です
        </section>
        <section data-markdown>
          ### RPN関数を作成
          * まずは型
          * 文字列をとって数を返す
          * 倍精度浮動少数で
          <pre><code contenteditable>
            solveRPN :: String -> Double
          </code></pre>
        </section>
        <section data-markdown>
          ### 自分の頭ではどうやったっけ
          1. スペース区切りの文字列をリストに分割 -> words
          1. リストを走査しスタックを更新 -> 畳込み
            * 今回はリストを左から走査するので左畳込み
          1. スタックはどう表現するか
            * リストの先頭をスタックの先頭に
            * リストはリストの先頭の操作が得意ですので、出入りの激しいスタックの先頭をリストの先頭に対応づけましょう
        </section>

        <section data-markdown>
          ### 関数の一部
          
          <pre><code>
          solveRPN :: String -> Double
          solveRPN expression = head (foldl foldingFunction [] (words expression))
            where foldingFunction stack item = ....
          </code></pre>
          
          * ポイントフリースタイルに向けて書きなおす
          
          <pre><code>
          solveRPN expression = head $ foldl foldingFunction [] $ words expression
            where foldingFunction stack item = ....
          </code></pre>

          * 更に↓

          <pre><code>
          solveRPN expression = head . foldl foldingFunction [] $ words expression
            where foldingFunction stack item = ....
          </code></pre>

          * 更に↓

          <pre><code>
          solveRPN = head . foldl foldingFunction [] . words
            where foldingFunction stack item = ....
          </code></pre>
        </section>
        <section data-markdown>
          ### 作ってみよう
          * 作ったり使ったりしてみよう
          * 続きはVimで
        </section>
        <section data-markdown>
          ### 失敗する場合も考えたいですね
          * 現在は不正な文字列が渡されるとプログラムが落ちる
          * 14章でMaybeモナドを学ぶと、失敗した際にNothingを返すなど綺麗に失敗させることができるようになりますので早く学びましょう
        </section>

        <section data-markdown>
          ## ヒースロー空港から<br>ロンドンへ
        </section>

        <section data-markdown>
          * とにかく早くヒースロー空港からロンドンに行きたい
          * ただしレンタカーで
        </section>

        <section data-markdown>
          (MacのPreview.appで作りました)

          <img src="path.png" />

          上記の図が下記文字列に対応

          * 50 10 30 5 90 20 40 2 25 10 8 0
          * 本当は、改行で区切られてます

        </section>

        <section data-markdown>
          ## こんな感じで解く
          1. 手で解く
          2. 手で解いた時に使ったデータ構造をHaskellで表現する
          3. そのデータ構造をどのようにHaskellで操作するか考える

          まぁ、このやり方が常にうまくいくわけではないでしょうが、<br>常に何がしかの手がかりは得られる方法ですよね
        </section>

        <section data-markdown>
          ## これからは教科書の<br>図を見ましょう

          * Preview.app、疲れた
        </section>

        <section data-markdown>
          ## 求めましょう
          * A1に行く最短経路とかかる時間
            * B Cで40分
          * B1に行く最短経路とかかる時間
            * Bで10分
        </section>

        <section data-markdown>
          ## A1,B1への時間を元に、以下を求めましょう
          * A2に行く最短経路とかかる時間
            * A1まで40分 + Aで45分
          * B2に行く最短経路とかかる時間
            * A1まで40分 + A Cで65分
        </section>

        <section data-markdown>
          ## 以下繰り返し

          (明らかに再帰ですね)

          最後に、A4とB4の所要時間を比べればめでたしめでたし
        </section>

        <section data-markdown>
          ## 手で解く方法は分かった

          * 続きはVimでやりましょう
          * ghciも交えながら
          * toLondon.hs参照
        </section>

      </div>
      
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
      
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/linear(2d)

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/zoom-js/zoom.js', condition: function() { return !!document.body.classList; } },
          { src: '/socket.io/socket.io.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
          { src: 'plugin/speakernotes/client.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } }
        ]
      });
      
    </script>

  </body>
</html>
